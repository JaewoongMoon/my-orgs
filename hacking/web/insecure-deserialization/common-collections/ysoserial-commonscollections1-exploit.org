#+TITLE: Understanding ysoserial's CommonsCollections1 exploit

#+MACRO: color @@html:<font color="$1">$2</font>@@

Last year(2015), ysoserial was released by frohoff and gebl. It is a fantastic piece of work. The tool provides options to generate several different types of serialized objects, which when deserialized, can result in arbitrary code execution if the right classes are present in the classpath. In this post, I will discuss the CommonsCollections1 exploit, and its working, available in the ysoserial toolkit. 

*All code snippets used in this post are sourced from ysoserial*


* An Overview
  The CommonsCollections1 exploit builds a custom AnnotationInvocationHandler object that contains an InvokerTransformer (Apache Commons Collections class)payload, and outputs the serializaed object. When the serialized object is deserialized, the code path from AnnotationInvocationHandler's readObject leads to InvokerTransformer's payload, causing code execution.

The image below shows the custom AnnotationInvocationHandler object used for RCE.

When the serialized object is deserialized, the code path from AnnotationInvocationHandler's readObject leads to Invoker Transformer's payload, causing code execution.

The image below shows the custom AnnotationInvocationHandler object used for RCE.
#+CAPTION: The serialized AnnotationInvocationHandler
[[./img/Serialized_Object_Structure.png]]

What makes the exploit effective is that it only relies on the classes present in Java and Apache Commons Collections. The CommonsCollections1 leverages following classes from JDK and Commons Collections. 

*From JDK*
#+BEGIN_VERSE
1. AnnotationInvocationHandler
2. Proxy
3. Map
4. Override
5. InvocationHandler
6. Runtime
#+END_VERSE

*From Commons Collections*
#+BEGIN_VERSE
1. LazyMap
2. Transformer
3. ChainedTransformer
4. InvokerTransformer
#+END_VERSE

So, as long a Java software stack contains Apache commons Collections library(<= 3.2.1), it will be vulnerable to remote execution attacks while deserializing untrusted objects. 

* Pre-requisities
It will be helpful to refer to the following Classes and concepts as we work our way to understaing the exploit. 

#+BEGIN_VERSE
1. Java Serialization and Deserialization mechanisms
2. {{{color(red,ObjectInputStream)}}} - including readObject()
3. {{{color(red,Proxy)}}} 
4. {{{color(red,InvocationHandler)}}} 
5. {{{color(red,Transformer)}}} 
6. {{{color(red,LazyMap)}}} 
7. {{{color(red,ChainedTransformer)}}} 
8. {{{color(red,InvokerTransformer)}}} - Instances of this class were used to perform code execution and we will discuss this in more details below. 
#+END_VERSE

Since InvokerTransformer class is the eventual sink that performs code execution, lets us take a closer look at it. An InvokerTransformer constructor takes three parameters:
#+BEGIN_VERSE
1. Name of the method
2. Parameter types the method accepts
3. Parameters values
#+END_VERSE

#+CAPTION: The constructor of InvokerTransformer
[[./img/InvokerTransformer-constructor.png]]

An InvokerTransformer instance accepts an object as input and outputs the transformed object. The tranformation is determined by the instatiation parameters. The InvokerTransformer first finds a method with the method name (specified as first parameter) that accepts the given parameters types (specified as second paramter) on the incoming object. Upon finding a matching method, the method on the incoming object and the parameter values from (3) as passed arguments into the method. The returned value is the value of the method execution. 

#+CAPTION: Shows InvokerTransformer
[[./img/InvokerTransformer.png]]


* Payload Only Execution


* Putting it all together







* Ref
[fn:1] http://gursevkalra.blogspot.jp/2016/01/ysoserial-commonscollections1-exploit.html
