* 개요
멜트다운 공격의 POC 코드를 분석


* 코드 분석
** 먼저 필요한 다음 두 가지 메모리 영역을 정의한다. 
- ua1 : L1캐시 크기만큼의 메모리 영역
- ua2 : L1캐시 라인 크기 (보통 64B) * (256+1) 만큼의 메모리 영역

** 슈도 코드
1. 1바이트 레지스터 al의 값을 256(0x100)으로 초기화한다. 

2. 8바이트 레지스터 rbx의 값을 커널 값을 읽을 타겟 주소로 초기화한다. 
(ua1의 값을 모두 L1 캐시로 가져오기 때문에, 이후 ua2를 포함한 다른 값들은 L1캐시에 없는 게 보장된다.)

3. ua1의 모든 값을 읽는다. (*캐시크기는 CPU마다 다른데 어떻게 프로그램에서 알 수 있지?*)

4. rbx가 가리키는 주소의 값을 읽어서 레지스터 al에 저장한다. 

5. al에 L1캐시 라인 크기(64)를 곱한 만큼 위치에서 ua2의 값을 읽는다. 즉, ua2[64 * al]을 읽는다.

6. ua2에서 캐시에 값이 들어올 주소를 알아낸다. 




** 보고된 코드
최초 보고자가 논문에서 밝히고 있는 코드와 위의 설명을 비교해가면서 이해해보자.

#+BEGIN_SRC assembly 
; rcx = kernel address
; rbx = probe array
retry:
mov al, byte [rcx]
shl rax, 0xc
jz retry
mov rbx, qword [rbx + rax]
#+END_SRC






* 참고 
- 나무위키 CPU 게이트 문서의 3.1.3 커널 값을 읽어내는 프로그램 : https://namu.wiki/w/CPU%EA%B2%8C%EC%9D%B4%ED%8A%B8#s-3.1

- 
