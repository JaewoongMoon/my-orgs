* Abstract
- 이 공격은 OS에 독립적이고 따라서 어떤 소프트웨어 취약점과도 관련이 없으며, 모든 OS상에서 실행가능하다.
- 멜트다운은 "주소 공간 격리"라는 보안 전제 자체를 허물어버린다.
- 다른 프로세스나 클라우드 상의 다른 가상머신의 메모리를 읽을 수 있다. 아무런 권한없이도. 
- 이 공격을 지연시키기위한 KAISER 메커니즘의 빠른 도입이 필요하다. 

* 1. Introduction
- 주소 공간 격리는 프로세스의 수퍼바이저 비트로 구현되는데, 이 비트의 값에 따라 커널 메모리에 접근할 수 있는지 없는지가 결정된다. 
- 이 비트는 커널코드에 들어갈 때 세팅(1로)되고 유저 프로세스로 스위칭될 때 지워진다.(0으로)
- 이 하드웨어적인 특성은 OS가 모든 프로세스의 주소공간에 커널을 매핑할 수 있도록 해준다. 
- 그래서 인터럽트 핸들링과 같은 유저 프로세스와 커널간의 스위칭을 할 수 있게 된다. 
- 결과적으로, 사실상 유저 프로세스와 커널간의 메모리 매핑을 임의적으로 바꿀 수 없다. 
- 멜트다운은 모든 현대 프로세스들이 제공하는 사이드 채널 정보를 이용한다. (2010년이 후의 인텔 CPU + 기타 다른 벤더사의 CPU들)
- /out-of-order-execution/에 의한 부작용이 주요한 원인이다.
- out-of-order execution은 현대의 프로세서들의 퍼포먼스에 관련된 중요한 특징
- 실행 유닛의 지연을 막기위함. 페치 유닛이 메모리로부터 데이터가 오는 것을 기다리는..
- 실행을 기다리는 대신에 명령어 구동 순서를 반대로 한다. 
- 그러나 부작용이 존재하는데 타이밍 차이이다. 이 것으로 인해 정보 누출이 발생한다. 
- 보안적인 관점에서 보면, Out-of-order는 CPU가 권한없는 프로세스에 권한이 있어야 접근가능한 (커널 or 물리) 주소를 임시 CPU 레지스터에 적재한다는 점이 치명적인 부분이다. 더욱이 이 값을 가지고 CPU가 실제로 연산을 수행하는다는 점.
- 실제로는 이런 프로그램 실행 결과는 탐지가 되고, 따라서 버려지게되므로, 보안 문제가 일어나지 않는 것처럼 보인다. 
- 그러나 이 out-or-order 메모리 룩업은 캐시에 영향을 주고, 캐시 사이드 채널을 통해서 접근할 수 있다.- 그 결과, 공격자는 out-of-order 스트림의 privileged 메모리를 전체 덤프를 떠서 데이터를 추출할 수 있다. (microarchitectual covert channel)


* 2. Background
** 2.1 Out-of-order execution
** 2.2 Address Spaces
** 2.3 Cache Attacks
Cache side-channel attacks exploit timing differences

예전부터 몇 가지 공격 방법이 공개되어 있었음. 

Evict + Time / Prime + Probe / Flush + Reload

이 중 Flush + Reload 공격 시, 공격자는 공격 대상 메모리 위치에 clflush 명령어 자꾸 실행시켜서 flush 를 시도. 

데이터가 리로딩되는 시간을 측정함으로서 공격자는 그 시간에 다른 프로세스에 의해 캐시에 로드된 데이터가 있는지를 판단할 수 있다. 

이 공격은 암호깨기 알고리즘이나 서버 펑션 콜, 유저 입력, 커널 어드레싱 정보 등을 계산하는데 사용할 수 있다. 그 중 특별한 형태가 covert channels 이다. 

공격자는 부작용을 낳는 부분과 부작용을 측정하는 부분을 동시에 활용한다. 


* 3. A Toy Example
out-of-order execution이 마이크로 아키텍처의 상태의 바꿀 수 있고, 정보가 노출될 수 있다는 것을 보여주기 위한 샘플이다. 

이 것이 멜트다운 공격을 위한 기본적인 지식이 된다. (4,5장)

예외가 일어나면 제어는 예외 핸들러에게 넘어가고 뒤의 코드(명령어들)은 실행되지 않는다. 그러나 out-of-order execution 환경에서는 이미 몇개의 명령어가 실행되었을 수 있고, 여전히 캐시에 남아있을 수 있다.

(역주: 예외의 의도적으로 일으킬 수 있고, 캐시의 정보를 빼낼 수 있는 공격이 가능하다면? 
이 행동을 반복하는 것으로 상당한 량의 정보를 빼낼 수 있을 것이다.)

사이드 채널 공격을 이용해서 어떤 메모리 영역이 캐싱되었는지 판단할 수 있다. 

* 4. Building Blocks of the Attack
** 4.1 Executing Transient Instructions
The first building block of Meltdown is *the execution of transient instructions*. Transient executions basically occur all the time, as the CPU continuously runs ahead of the current instruction to minimize the experienced latency and thus maximize the performance. Transient instructions introduce an exploitable side channel if their operation depends on a secret value. 

Accessing user-inaccessible pages, such as kernel pages, triggers an exception which generally terminates the application. If the attacker targets a secret at a user-inaccessible address, the attacker has to cope with this exception. We propose two approaches: With /exception handling/, we catch the exception effectively occuring after executing the transient instruction sequence, and with /exception suppression/, we prevent the exception from occurring at all and instead redirect the control flow after executing the transient instruction sequence. We disscuss these approaches in detail in the following. 

유저가 접근하면 안되는 메모리에 접근했을 때 예외가 발생하기 때문에, 공격자는 이 예외를 다룰 수 있어야 한다. 이를 위한 방법으로 exception handling(예외가 발생했을 때 적절히 처리) 과 excepiton suppression(아예 예외가 발생하지 않도록 억누르는 것)의 두 가지 방법이 있다. 

*** Exception handling
A trivial approach is to fork the attacking application before accessing the invalid memory location that terminates the process, and only access the invalid memoery location in the child process. The CPU executes the transient instruction sequence in the child process before crashing. The parent process can then recover the secret by observing the microarchitectural state, e.g., through a side-channel. 

 It is also possible to install a signal handler that will be executed if a certain exceptions occurs, in this specific case a segmentation fault. This allows the attacker to issue the instruction sequence and prevent the application from crashing, reducing the overhead as no new process has to be created. 

*** Exception suppression
A different approach to deal with exceptions is to prevent them from being raised in the first place. Transactional memory allows to group memory accesses into one seemingly atomic operation, giving the option to roll-back to a previous state if an error occurs. If an exception occurs within the transaction, the architectural state is reset, and the program execution continues without disruption. 

 Furthermore, speculative execution issues instructions that might not occur on the executed code path due to a branch misprediction. Such instructions depending on a preceding conditional branch can be speculatively executed. Thus, the invalid memory access is put within a speculative instruction...
 



** 4.2 Building a Covert Channel



* 5. Meltdown

** Attack Setting

** 5.1 Attack Description

*** Step 1 : Reading the secret.

*** Step 2 : Transmitting the secret.

*** Step 3 : Receiving the secret. 

*** Dumping the entire physical memory.


** 5.2 Optimizations and Limitations




* 6. Evaluation



* 7. Countermeasures


* 8. Discussion


* 9. Conclusion


