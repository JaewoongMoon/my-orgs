#+TITLE: CPU Micro Architecture

* 파이프라인
CPU가 하나의 명령어를 처리하는 과정이 복잡하기 때문에 이를 잘게 쪼갠 작은 단계로 나누어 처리하는 방식

다음 8단계로 나눔. 순서대로 진행된다.

- Fetch : 실행할 명령어를 주메모리에서 가져온다. 

- Decode : 명령어가 어떤 것인지 해독한다. 

- Rename: 명령어가 쓸 물리 레지스터를 할당한다. 가령 레지스터 eax에 값을 저장하는 명령어라면, 실행이 완료될 때까지 *사용자에게 노출되지 않는 물리 레지스터* 에 값을 저장하고, 명령어가 최종적으로 완료되면 그때가 돼서야 값을 노출시킨다. 

- Dispatch : 명령어가 Re-Order Buffer (ROB)의 맨 뒤에 들어간다. 다음 단계인 Issue -> Execute -> Writeback까지는 나중에 온 명령어가 먼저 수행될 수 있는데 (Out-of-order execution), 최종적으로 명령어가 나갈 때는 원래 순서를 지켜서 유저는 순서가 바뀐 것을 알아챌 수 없게 하기 위해 ROB 맨 뒤에 넣는다. 


- Issue : 명령어가 execute 단계에 필요한 자원이 준비되면 보낸다. 가령 레지스터 eax에 1을 더하는 명령어라면 일단 eax의 최신 값을 만들어내는 이전 명령어가 아래의 writeback 단계를 완료할 필요가 있다.

- Execute : 명령어를 실제로 수행한다. 가령 계산이나 주메모리에서 값을 읽어오거나 하는 것들이 이 때 수행된다. 

- Writeback: 만들어낸 결과값을 rename 단계에 할당받은 물리 레지스터에 저장한다. 이 값을 기다리던 명령어들에 알려주는 것도 덤이다. 

- Commit : *사용자에게 노출되지 않는 물리 레지스터* 를 이제 사용자에게 노출시킨다. 



* Out-of-Order Execution(OoOE)
OoOE는 파이프라인의 Issue -> Execute -> Writeback 단계에 한해서 늦게 온 명령어가 일찍 온 명령어를 새치기 할 수 있는 기술이다. 앞에 온 명령어의 처리가 수행될 수 없지만 뒤에 온 명령어는 수행가능한 경우가 나올 수 있는데, 그러면 CPU를 놀게 하기보다 뒤에 온 명령어를 먼저 처리하자는 거다. 물론 아무 때가 막 할 수는 없고 순서를 바꿔도 사용자가 보는 값이 OoOE를 하지 않았을 때와 같은 경우만 할 수 있다. 

* 참고 
https://namu.wiki/w/CPU%EA%B2%8C%EC%9D%B4%ED%8A%B8?from=2018%EB%85%84%20%EC%9D%B8%ED%85%94%20CPU%20%EB%B3%B4%EC%95%88%20%EB%B2%84%EA%B7%B8%20%EC%9C%A0%EC%B6%9C

