* 배경
- 주메모리에서 값을 읽는 동작은 CPU의 명령어 처리 속도에 비하면 한참 느림
- 이 갭을 줄이기 위해 CPU에 설치한 매우 빠르지만 작은 저장공간이 캐시
- 캐시는 공간이 작기 때문에 새로운 값을 읽어들이려면 기존 값을 다시 원래 위치로 돌려보내야 함
- 이 때, 주로 가장 오래된 값을 돌려보내는 방식을 취한다. 
- 이는 최근에 접근한 값을 또 접근할 가능성이 높기 때문(참조 지역성의 원리, Principle of locality)
- 또한 한 값을 읽으면 그 근처의 값을 읽을 확률이 높은 점을 활용하기 위해 어떤 값을 캐시로 가져올 때 그 주변의 값도 같이 가져온다. (이 것도 참조지역성의 원리)
- 이렇게 캐시에 값이 들어오는 덩어리를 캐시 라인이라고 함 (보통 64바이트)

* 캐시 메모리 관련
- 캐시 메모리의 크기는 32KB~8MB 정도. 엄청 빠르고 비쌈
- 프로그래머는 캐시를 직접 사용할 수 없다(존재가 외부에 드러나지 않음)

* L1,L2,L3 캐시
캐시는 용량이 클수록 데이터 전송속도가 느려지고, 기억밀도가 높으며 전력을 절약하는 성질이 있으므로 이 것을 적절히 활용하여 필요에 따라 L1,L2,L3 로 나뉘어 있음

- L1 캐시 : 32KB (자기전용책상)
- L2 캐시 : 256KB (캐비넷)
- L3 캐시 : 2MB (지하자료보관소) L2캐시와 L3캐시 사이의 데이터 전달은 버스터가 해준다
- 주기억장치(DRAM, 이하 메모리) : 4GB~16GB (교외창고)



* 캐시 라인(캐시 블록)
- 데이터가 메모리에서 캐시로 복사될 때 고정된 크기의 블록으로 전송되는데, 이 블록을 캐시 라인 또는 캐시 블록이라고 부른다. 
- 캐시 라인이 메모리로부터 캐시에 복사될 때, 캐시 엔트리라고 하는 것이 생성된다.
- 캐시 엔트리에는 복사된 데이터와 요청된 메모리 주소(태그라고 불림)가 들어있다. 
- 캐시 엔트리의 구조
|-----+------------+-----------|
| tag | data block | flag bits |
|-----+------------+-----------|

* 캐시의 크기는 CPU마다 다른가?
YES

예를 들어 인텔 펜티엄4 CPU의 L1캐시 사이즈는 8KB이고 캐시 블록 사이즈는 64바이트이다.
그러므로 8KB/64B = 128 개의 캐시블록을 사용가능. 


* 참고 
- 나무위키 캐시 메모리 : https://namu.wiki/w/%EC%BA%90%EC%8B%9C%20%EB%A9%94%EB%AA%A8%EB%A6%AC
- CPU의 캐시 L1, L2, L3는 왜 나뉘어 있나? : http://process0modesty.tistory.com/163
- 위키 피디아 캐시 메모리: https://en.wikipedia.org/wiki/CPU_cache
- 나무위키 CPU 게이트 : https://namu.wiki/w/CPU%EA%B2%8C%EC%9D%B4%ED%8A%B8#rfn-25
